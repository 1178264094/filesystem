<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Filesystem Relative Proposal</title>
<link href="styles.css" rel="stylesheet">
</head>

<body>

<table border="0" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111">
  <tr>
    <td width="277">
<a href="../../../index.htm">
<img src="../../../boost.png" alt="boost.png (6897 bytes)" align="middle" width="300" height="86" border="0"></a></td>
    <td align="middle">
    <font size="7">Filesystem Relative Proposal</font>
    </td>
  </tr>
</table>

<table border="0" cellpadding="5" cellspacing="0" style="border-collapse: collapse"
 bordercolor="#111111" bgcolor="#D7EEFF" width="100%">
  <tr>
    <td><a href="index.htm">Home</a> &nbsp;&nbsp;
    <a href="tutorial.html">Tutorial</a> &nbsp;&nbsp;
    <a href="reference.html">Reference</a> &nbsp;&nbsp;
    <a href="faq.htm">FAQ</a> &nbsp;&nbsp;
    <a href="release_history.html">Releases</a> &nbsp;&nbsp;
    <a href="portability_guide.htm">Portability</a> &nbsp;&nbsp;
    <a href="v3.html">V3 Intro</a> &nbsp;&nbsp;
    <a href="v3_design.html">V3 Design</a> &nbsp;&nbsp;
    <a href="deprecated.html">Deprecated</a> &nbsp;&nbsp;
    <a href="issue_reporting.html">Bug Reports </a>&nbsp;&nbsp;
    </td>
</table>

<p>
      <br>
</p>
<h2>Proposed wording</h2>

<h3>New class path member functions</h3>

<p>The&nbsp; <code>normal</code> and <code>
relative</code> member functions, like all member functions of class <code>path</code>, perform lexical processing 
only. They do not 
follow symlinks.</p>

<p>These semantics are useful for operating on paths that do not currently exist 
or on paths generated by operational non-member functions that resolve symlinks.</p>

<pre>path normal() const;</pre>
<blockquote>
<p><i>Returns:</i> A path with the same elements&nbsp; as <code>*this</code> 
except that redundant current (<i>dot</i>) directory and name element followed 
by parent (<i>dot-dot</i>) directory elements are removed. If the returned path 
would otherwise be empty, a path containing a single current (<i>dot</i>) 
directory is returned.</p>
<p><i>Remarks:</i> Uses <code>operator/=</code> to compose the returned path.</p>
<p>[<i>Example:</i></p>
<p><code>assert(path(&quot;foo/./bar/..&quot;).normal() == path(&quot;foo&quot;);<br>
assert(path(&quot;foo/./bar/../&quot;).normal() == path(&quot;foo/.&quot;);</code></p>
<p dir="ltr">All of the above asserts would succeed.<i> </i>On Windows, the 
returned path&#39;s separators would be backslashes rather than slashes, but that 
does not affect equality.<i> —end example</i>]</p>
</blockquote>

<pre>path relative(const path&amp; base) const;</pre>
<blockquote>
  
  <p><i>Returns:</i> </p>
  
  <ul>
    <li>
  <p><code>path()</code> if the first mismatched element of <code>
  *this</code> is equal to <code>begin()</code> and the first mismatched element 
  of <code>base</code> is equal to <code>&nbsp;base.begin()</code>, or<br>
&nbsp;</p>
  
    </li>
    <li>
  <p><code>path(&quot;.&quot;)</code> if the first mismatched element of <code>
  *this</code> is equal to <code>end()</code> and the first mismatched element 
  of base is equal to <code>base.end()</code>, or<br>
&nbsp;</p>
  
    </li>
    <li>An object of class <code>path</code> composed via application of <code>
    operator/= path(&quot;..&quot;)</code> for each element in the sequence [first 
    mismatched element of <code>base</code>, <code>base.end()</code>), and then 
    application of <code>operator/=</code> for each element in the sequence 
    [first mismatched element of <code>p</code>, <code>p.end()</code>).</li>
</ul>
  <p><i>Remarks:</i> Uses <code>std::mismatch(begin(), end(), 
  base.begin(), base.end())</code> to determine the first mismatched element. 
  Path equality is determined by <code>operator==</code>. Uses <code>operator/=</code> 
  to compose the returned path.</p>
  
  <p dir="ltr">[<i>Note:</i> Use the non-member operational function <code>relative</code> 
  if symlink following semantics are desired. <i>—end note</i>]</p>
  
  <p dir="ltr">[<i>Note:</i> Use the <code>normal</code> function to preprocess . <i>—end note</i>]</p>
  
<p>[<i>Example:</i></p>
<p><code>assert(path(&quot;/a/d&quot;).relative(&quot;/a/b/c&quot;) == path(&quot;../../d&quot;));<br>
assert(path(&quot;/a/b/c&quot;).relative(&quot;/a/d&quot;) == path(&quot;../b/c&quot;));<br>
assert(path(&quot;a/b/c&quot;).relative(&quot;a&quot;) == path(&quot;b/c&quot;));<br>
assert(path(&quot;a/b/c&quot;).relative(&quot;a/b/c/x/y&quot;) == path(&quot;../..&quot;));<br>
assert(path(&quot;a/b/c&quot;).relative(&quot;a/b/c&quot;) == path(&quot;.&quot;));</code></p>
<p dir="ltr">All of the above asserts would succeed.<i> </i>On Windows, the 
returned path&#39;s separators would be backslashes rather than slashes, but that 
does not affect equality.<i> —end example</i>]</p>
  
</blockquote>
<h3>New operational functions</h3>
<pre>path weakly_canonical(const path&amp; p);
path weakly_canonical(const path&amp; p, system::error_code&amp; ec);</pre>
<blockquote>
Returns:<ul>
  <li>
  <p>If <code>exists(p)</code>, <code>canonical(p)</code><br>
&nbsp;</li>
  <li>
  <p>Otherwise, <code>p.parent_path().empty()<br>
&nbsp;? p<br>
&nbsp;: weakly_canonical(p.parent_path()) / p.filename()</code>.</li>
</ul>
<p><i>Remarks:</i> An implementation may use iteration 
rather than recursion.</p>
<p><i>Throws:</i>&nbsp; As specified in Error reporting.</p>
</blockquote>
<pre>path relative(const path&amp; p, system::error_code&amp; ec);</pre>
<blockquote>
<p><i>Returns:</i> <code>relative(p, current_path(), ec)</code>.</p>
  <p><i>Throws:</i>&nbsp; As specified in Error reporting.</p>
  
  </blockquote>
<pre>path relative(const path&amp; p, const path&amp; base=current_path());
path relative(const path&amp; p, const path&amp; base, system::error_code&amp; ec);</pre>
<blockquote>
<p><i>Returns:</i> <code>weakly_canonical(p<i>[, ec]</i>).relative(weakly_canonical(base<i>[, 
ec]</i>))</code>. The second form returns <code><span style="font-size: 85%">
path()</span></code> if an error occurs.</p>
  <p><i>Throws:</i> As specified in Error reporting.</p>
  <p>[<i>Note:</i> For two paths <code>a</code> and <code>b</code> that both exist,
  <code>relative(a, b)</code> is equivalent 
  to <code>canonical(a).relative(canonical(b))</code>. </p>
  <p>For two paths <code>a</code> and <code>b</code> neither of which exist,
  <code>relative(a, b)</code> is equivalent 
  to <code>a.relative(b)</code><font face="Courier New">. </font><i>—end note</i>]</p>
</blockquote>

<hr>
<p>© Copyright Beman Dawes 2015</p>
<p>Distributed under the Boost Software License, Version 1.0. See
<a href="http://www.boost.org/LICENSE_1_0.txt">www.boost.org/LICENSE_1_0.txt</a></p>
<p>Revised
<!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%d %B %Y" startspan -->12 August 2015<!--webbot bot="Timestamp" endspan i-checksum="31417" --></p>

</body>

</html>